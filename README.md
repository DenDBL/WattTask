
#  Описание архитектуры

В проекте присутствует базовый класс Плюша ABasePlushe, который имеет в себе поле для настроек вида Плюша. Для разных Плюшей задаётся разный UDataAsset (UPlusheTypeDataAsset). Для примера в проекте есть два дочерних Плюша с разными дата-ассетами с разными настройками. Для Плюша есть мастер-дерево BehaviorTree (BT_Plushe), в котором в зависимости от состояния плюша (Aggressive, Shy, Tamed) исполняется соответствующее  поведение через поддеревья (BT_AggressivePlushe, BT_ShyPlushe, BT_TamedPlushe). Благодаря этому мы можем менять динамически состояние и соответственно  поведение Плюша, передавая через общий метод новое состояние. Для нового другого состояния можно добавлять ответвление в мастер-дереве.  
Гаджет реализован в виде LineTrace'а в CPP классе персонажа игрока. Если гаджет во что-то "попадает", то он через интерфейс пытается вызвать функционал объекта. Такой интерфейс реализован в базовом классе Плюша, в котором происходит  изменения состояния. Если необходим другой функционал при реагировании на гаджет, его можно переопределить в дочерних классах базового  Плюша.

#  Масштабируемость

В рамках этой архитектуры дополнительный функционал можно добавить, расширяя Behavior Tree и использую интерфейсы, которые можно переопределить в дочерних классах базового класса. Дополнительное поведение в зависимости от состояния Плюша можно добавлять в мастер-дереве. Также Behavior Tree может вызывать у пользователя дерева таск атаки, который вызывает интерфейс у владельца, по-разному переопределённый  в дочерних классах в зависимости от типа, или реализовать интерфейс реагирования на гаджет в разных дочерних классах так, чтобы у них была особенная реакция на гаджет игрока. 

# Сетевая игра

В контексте задачи можно реплицировать  с сервера на клиенты CharacterMovementComponent для репликации движения персонажей и состояния Плюша для возможного отображения  какого либо визуала на клиентах, зависящего от типа Плюша.

# Оптимизация

Большое количество персонажей на уровне приведёт к сильной нагрузке на CPU, что наверняка приведёт к потере FPS. Если размер уровня позволяет, можно распределить это количество NPC по уровню, чтобы можно было грамотно настроить LODы для анимаций и  моделей для слабовидимых персонажей. Также для отдаленных юнитов можно использовать более упрощенное AI-поведние. Помимо этого я бы избегал в логике NPC частого использования циклов перебора юнитов, выводил это в асинхрон и кэшировал данные, чтобы реже прибегать к циклам. 

# Запуск проекта
Используется UE версии 5.4  
Проект запускается стандартным методом:

ПКМ по Проекту-> Generate Visual Studio Project Files -> Сборка и запуск проекта через IDE -> Play In Editor на начальном левеле

Управление на WASD  
Использование гаджета на ЛКМ


